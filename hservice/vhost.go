package hservice

import (
	"encoding/json"
	"fmt"
	"net/http"
	"sync"
	"time"

	"github.com/dianpeng/mono-service/alog"
	cfg "github.com/dianpeng/mono-service/config"
	"github.com/dianpeng/mono-service/g"
	"github.com/dianpeng/mono-service/hclient"
	"github.com/dianpeng/mono-service/hpl"
	"github.com/dianpeng/mono-service/hrouter"
	_ "github.com/dianpeng/mono-service/module"
	"github.com/dianpeng/mono-service/phase"
	"github.com/dianpeng/mono-service/pl"
	"github.com/dianpeng/mono-service/service"
	"github.com/dianpeng/mono-service/util"
	"github.com/gorilla/mux"
)

type SessionHandler interface {
	phase.PhaseAccess
	phase.PhaseRequest
	phase.PhaseResponse
	phase.PhaseLog

	CurrentSession() service.Session
}

type sessionPool struct {
	idle    []*sessionHandler
	maxSize int
	sync.Mutex
}

type vhostService struct {
	svc         service.Service
	policy      *pl.Policy
	config      *cfg.Service
	vhost       *VHost
	sessionPool sessionPool
}

type sessionHandler struct {
	session          service.Session
	hpl              *hpl.Hpl
	svc              *vhostService
	activeHttpClient []*hclient.HClient

	// result generated by session.Accept function which will be used during
	// phase response
	sessionResult    service.SessionResult
	phase            string
	phaseIndex       int
	errorDescription string
	inError          bool

	// action generation
	errorStatus int
	errorBody   string
}

type VHost struct {
	Name          string
	ActiveService []*vhostService
	Router        *mux.Router
	HttpServer    *http.Server
	LogFormat     *alog.SessionLogFormat
	ErrorStatus   int
	ErrorBody     string
	RejectStatus  int
	RejectBody    string

	clientPool *hclient.HClientPool
}

const (
	responseUninit = iota
	responseHeader
	responseBody
)

type responseWriterWrapper struct {
	w      http.ResponseWriter
	status int
	stage  int
}

func newSessionPool(config *cfg.Service) sessionPool {
	cache_size := config.MaxSessionCacheSize
	if cache_size == 0 {
		cache_size = g.MaxSessionCacheSize
	}
	return sessionPool{
		maxSize: cache_size,
	}
}

func (s *sessionPool) idleSize() int {
	s.Lock()
	defer s.Unlock()
	return len(s.idle)
}

func (s *sessionPool) get() *sessionHandler {
	s.Lock()
	defer s.Unlock()
	if len(s.idle) == 0 {
		return nil
	}
	idleSize := len(s.idle)
	last := s.idle[idleSize-1]
	s.idle = s.idle[:idleSize-1]
	return last
}

func (s *sessionPool) put(h *sessionHandler) bool {
	s.Lock()
	defer s.Unlock()
	if len(s.idle)+1 >= s.maxSize {
		return false
	}
	s.idle = append(s.idle, h)
	return true
}

func (s *vhostService) getSessionHandler() (*sessionHandler, error) {
	// try to get a session handler from the pool
	if h := s.sessionPool.get(); h != nil {
		return h, nil
	}

	// create a new one
	if session, err := s.svc.NewSession(); err != nil {
		return newSessionHandler(nil, s), err
	} else {
		return newSessionHandler(session, s), nil
	}
}

func newvhostService(vhost *VHost, svc service.Service, config *cfg.Service) (*vhostService, error) {
	p, err := pl.CompilePolicy(config.Policy)
	if err != nil {
		return nil, err
	}
	return &vhostService{
		svc:         svc,
		policy:      p,
		config:      config,
		vhost:       vhost,
		sessionPool: newSessionPool(config),
	}, nil
}

func newSessionHandler(s service.Session, svc *vhostService) *sessionHandler {
	h := &sessionHandler{
		session: s,
		hpl:     hpl.NewHplWithPolicy(svc.policy),
		svc:     svc,
	}
	return h
}

// implementation of sessionHandler --------------------------------------------
func (s *sessionHandler) setPhase(p int, n string) {
	s.phaseIndex = p
	s.phase = n
}

func (s *sessionHandler) GetHttpClient(url string) (hpl.HttpClient, error) {
	c, err := s.svc.vhost.clientPool.Get(url)
	if err != nil {
		return nil, err
	}
	s.activeHttpClient = append(s.activeHttpClient, &c)
	return &c, nil
}

// SessionWrapper
func (s *sessionHandler) OnLoadVar(e *pl.Evaluator, name string) (pl.Val, error) {
	if s.inError {
		return pl.NewValNull(), fmt.Errorf("unknown variable: %s", name)
	}

	if s.phaseIndex == phase.PhaseHttpResponse {
		for _, x := range s.sessionResult.Vars {
			if x.Key == name {
				return x.Value, nil
			}
		}
	}

	return s.session.OnLoadVar(s.phaseIndex, e, name)
}

func (s *sessionHandler) OnStoreVar(e *pl.Evaluator, name string, v pl.Val) error {
	if s.inError {
		return fmt.Errorf("unknown variable for storing: %s", name)
	}

	return s.session.OnStoreVar(s.phaseIndex, e, name, v)
}

func (s *sessionHandler) OnCall(e *pl.Evaluator, name string, args []pl.Val) (pl.Val, error) {
	if s.inError {
		return pl.NewValNull(), fmt.Errorf("unknown function: %s", name)
	}

	return s.session.OnCall(s.phaseIndex, e, name, args)
}

func (s *sessionHandler) OnAction(e *pl.Evaluator, name string, v pl.Val) error {
	if s.inError {
		switch name {
		case "status":
			if v.Type == pl.ValInt {
				s.errorStatus = int(v.Int())
				return nil
			} else {
				return fmt.Errorf("invalid type for action status")
			}
		case "body":
			if v.Type == pl.ValStr {
				s.errorBody = v.String()
				return nil
			} else {
				return fmt.Errorf("invalid type for action body")
			}

		default:
			return fmt.Errorf("unknown action: %s", name)
		}
	}
	return s.session.OnAction(s.phaseIndex, e, name, v)
}

func (s *sessionHandler) GetPhaseName() string {
	return s.phase
}

func (s *sessionHandler) GetErrorDescription() string {
	return s.errorDescription
}

// phase handler ---------------------------------------------------------------
func (s *sessionHandler) Access(req *http.Request, p hrouter.Params) error {
	return s.hpl.OnAccess("access", req, p, s)
}

func (s *sessionHandler) Request(req *http.Request, p hrouter.Params) error {
	return s.hpl.OnRequest("request", req, p, s)
}

func (s *sessionHandler) Response(w http.ResponseWriter,
	req *http.Request,
	p hrouter.Params,
) error {
	return s.hpl.OnResponse(s.sessionResult.Event, w, req, p, s)
}

func (s *sessionHandler) Log(log *alog.SessionLog) error {
	return s.hpl.OnLog("log", log, s)
}

func (s *sessionHandler) Error(status int, text string) error {
	s.inError = true
	s.errorStatus = status
	s.errorBody = text
	return s.hpl.OnError("error", s)
}

// interface for alog.VHostInformation
func (s *sessionHandler) VHostName() string {
	return s.svc.vhost.Name
}

func (s *sessionHandler) VHostEndpoint() string {
	return s.svc.vhost.HttpServer.Addr
}

// interface for alog.SessionInfo
func (s *sessionHandler) ServiceName() string {
	return s.session.Service().Name()
}

func (s *sessionHandler) SessionPhase() string {
	return s.phase
}

func (s *sessionHandler) ErrorDescription() string {
	return s.errorDescription
}

func (s *sessionHandler) init() error {
	return s.hpl.OnInit(s)
}

func (s *sessionHandler) finish() {
	// http client pool draining operations
	if s.activeHttpClient != nil {
		for _, c := range s.activeHttpClient {
			s.svc.vhost.clientPool.Put(*c)
		}
	}
}

// builtin handlers
func (h *VHost) httpListService(w http.ResponseWriter, _ *http.Request) {
	var o []interface{}

	for _, svc := range h.ActiveService {
		o = append(o, map[string]interface{}{
			"name":           svc.config.Name,
			"tag":            svc.config.Tag,
			"idl":            util.JSONSplitLine(svc.svc.IDL()),
			"policy":         util.JSONSplitLine(svc.config.Policy),
			"policyDump":     util.JSONSplitLine(svc.policy.Dump()),
			"router":         svc.config.Router,
			"methodList":     svc.config.Method,
			"idleSession":    svc.sessionPool.idleSize(),
			"maxSessionSize": svc.sessionPool.maxSize,
		})
	}

	blob, _ := json.Marshal(o)
	w.WriteHeader(200)
	w.Write(blob)
}

func (h *VHost) httpListImpl(w http.ResponseWriter, _ *http.Request) {
	var o []interface{}
	service.ForeachServiceFactory(
		func(svc service.ServiceFactory) {
			o = append(o, map[string]interface{}{
				"name":    svc.Name(),
				"idl":     svc.IDL(),
				"comment": util.JSONSplitLine(svc.Comment()),
			})
		},
	)

	blob, _ := json.Marshal(o)
	w.WriteHeader(200)
	w.Write(blob)
}

func (h *VHost) httpInfo(w http.ResponseWriter, _ *http.Request) {
	o := make(map[string]interface{})
	o["name"] = h.Name
	o["serviceNumber"] = len(h.ActiveService)
	o["endpoint"] = h.HttpServer.Addr
	o["logFormat"] = h.LogFormat.Raw
	o["errorStatus"] = h.ErrorStatus
	o["errorBody"] = h.ErrorBody
	o["rejectStatus"] = h.RejectStatus
	o["rejectBody"] = h.RejectBody
	o["httpClientPool"] = h.clientPool.Stats()

	blob, _ := json.Marshal(o)
	w.WriteHeader(200)
	w.Write(blob)
}

func (h *VHost) builtinHandler(r *mux.Router) {
	r.HandleFunc(fmt.Sprintf("/vhost/%s/info", h.Name), h.httpInfo).Methods("GET")
	r.HandleFunc(fmt.Sprintf("/vhost/%s/service/list", h.Name), h.httpListService).Methods("GET")
	r.HandleFunc(fmt.Sprintf("/vhost/%s/impl/list", h.Name), h.httpListImpl).Methods("GET")
}

// interface alog.HttpResponseSummary
func (r *responseWriterWrapper) Status() int {
	return r.status
}

// interface http.ResponseWriter
func (r *responseWriterWrapper) Header() http.Header {
	return r.w.Header()
}

func (r *responseWriterWrapper) Write(input []byte) (int, error) {
	r.stage = responseBody
	return r.w.Write(input)
}

func (r *responseWriterWrapper) WriteHeader(status int) {
	if r.stage == responseBody {
		return
	}

	r.stage = responseHeader
	r.status = status
	r.w.WriteHeader(status)
}

func (r *responseWriterWrapper) ReplyIfNeed(
	status int,
	body string,
) bool {
	if r.stage == responseUninit {
		r.w.WriteHeader(status)
		r.w.Write([]byte(body))
		return true
	}
	return false
}

func (v *VHost) doLog(_ *alog.SessionLog) {
	// TODO(dpeng): Add log sinking services
}

func (v *VHost) doPhaseError(
	_ *vhostService,
	h *sessionHandler,
	w *responseWriterWrapper,
	_ *http.Request,
	_ hrouter.Params,
	err error,
	pindex int,
) {
	var statusCode int
	var statusBody string

	switch pindex {
	case phase.PhaseHttpAccess:
		statusCode = v.RejectStatus
		statusBody = fmt.Sprintf("%s: %s", v.RejectBody, err.Error())
		break

	default:
		statusCode = v.ErrorStatus
		statusBody = fmt.Sprintf("%s: %s", v.ErrorBody, err.Error())
		break
	}

	h.Error(statusCode, statusBody)
	w.ReplyIfNeed(h.errorStatus, h.errorBody)
}

// Session interface defined 3 stages for each module/services
func (v *VHost) doPhase(asvc *vhostService, w http.ResponseWriter, req *http.Request) {
	param := hrouter.NewParams(req)
	respW := &responseWriterWrapper{
		w: w,
	}

	// notes even err is returned, the handler is always valid for later reuse
	handler, err := asvc.getSessionHandler()

	if err != nil {
		v.doPhaseError(asvc, handler, respW, req, param, err, phase.PhaseCreateSessionHandler)
		handler = nil
		return
	}

	log := &alog.SessionLog{
		Format:              v.LogFormat,
		HttpRequest:         req,
		RouterParams:        param,
		HttpResponseSummary: respW,
		VHost:               handler,
		Session:             handler,
	}

	defer func() {
		v.doLog(log)
		if handler != nil {
			handler.finish()
			asvc.sessionPool.put(handler)
		}
	}()

	// 0. Run HPL setup
	{
		handler.setPhase(phase.PhaseInit, ".init")
		if err := handler.init(); err != nil {
			handler.errorDescription = err.Error()
			v.doPhaseError(asvc, handler, respW, req, param, err, phase.PhaseInit)
			return
		}
	}

	// 1. PhaseAccess
	{
		handler.setPhase(phase.PhaseHttpAccess, "http.access")
		if err := handler.Access(req, param); err != nil {
			handler.errorDescription = err.Error()
			v.doPhaseError(asvc, handler, respW, req, param, err, phase.PhaseHttpAccess)
			return
		}
	}

	// 2. PhaseRequest
	{
		handler.setPhase(phase.PhaseHttpRequest, "http.request")
		if err := handler.Request(req, param); err != nil {
			handler.errorDescription = err.Error()
			v.doPhaseError(asvc, handler, respW, req, param, err, phase.PhaseHttpRequest)
			return
		}
	}

	// 3. Run the session
	var sessionCtx interface{}
	{
		// 3.1) run session's start handler
		handler.setPhase(phase.PhaseSessionStart, "session.start")
		if err := handler.session.Start(handler); err != nil {
			handler.errorDescription = err.Error()
			v.doPhaseError(asvc, handler, respW, req, param, err, phase.PhaseSessionStart)
			return
		}
	}

	{
		// 3.2) run the session's prepare handler to create internal structure for
		//      using by the sessions
		handler.setPhase(phase.PhaseSessionPrepare, "session.prepare")
		if ctx, err := handler.session.Prepare(req, param); err != nil {
			handler.errorDescription = err.Error()
			v.doPhaseError(asvc, handler, respW, req, param, err, phase.PhaseSessionPrepare)
			return
		} else {
			sessionCtx = ctx
		}
	}

	{
		// 3.3) run the session accept handler
		handler.setPhase(phase.PhaseSessionAccept, "session.accept")
		if r, err := handler.session.Accept(sessionCtx, handler.hpl); err != nil {
			handler.errorDescription = err.Error()
			v.doPhaseError(asvc, handler, respW, req, param, err, phase.PhaseSessionAccept)
			return
		} else {
			handler.sessionResult = r
		}
	}

	// 4. Generate the http response based on sessions result
	{
		handler.setPhase(phase.PhaseHttpResponse, "http.response")
		if err := handler.Response(respW, req, param); err != nil {
			handler.errorDescription = err.Error()
			v.doPhaseError(asvc, handler, respW, req, param, err, phase.PhaseHttpResponse)
			return
		}
	}

	// Notes, we need to invoke session's done handler *after* the response been
	// generated since the session handler may have some data used by the response
	// handler
	{
		// 3.4) run the session's done handler
		handler.setPhase(phase.PhaseSessionDone, "session.done")
		handler.session.Done(sessionCtx)
	}

	// 5. Lastly log generation
	{
		handler.setPhase(phase.PhaseAccessLog, ".access_log")
		handler.Log(log)
	}
}

func (h *VHost) Run() {
	h.HttpServer.ListenAndServe()
}

// router creation and preparation
func (h *VHost) newRouter(asvc *vhostService, rc *cfg.Router, r *mux.Router) (the_error error) {
	defer func() {
		if err := recover(); err != nil {
			the_error = fmt.Errorf("router creation failed: %s", err)
		}
	}()

	if rc.Path == "" {
		return fmt.Errorf("router.path is not properly configured")
	}

	rr := r.HandleFunc(rc.Path, func(w http.ResponseWriter, req *http.Request) {
		h.doPhase(asvc, w, req)
	})

	// setup method
	if len(rc.Method) != 0 {
		rr.Methods(rc.Method...)
	}

	// setup host
	if rc.Host != "" {
		rr.Host(rc.Host)
	}

	// setup query
	for _, kv := range rc.Query {
		rr.Queries(kv.Key, kv.Value)
	}

	return nil
}

func newVHost(config *cfg.VHost) (*VHost, error) {
	vhost := &VHost{}
	router := mux.NewRouter()

	// misc
	vhost.ErrorStatus = cfg.NotZeroInt(
		vhost.ErrorStatus,
		g.VHostErrorStatus,
	)
	vhost.ErrorBody = cfg.NotZeroStr(
		vhost.ErrorBody,
		g.VHostErrorBody,
	)

	vhost.RejectStatus = cfg.NotZeroInt(
		vhost.RejectStatus,
		g.VHostRejectStatus,
	)
	vhost.RejectBody = cfg.NotZeroStr(
		vhost.RejectBody,
		g.VHostRejectBody,
	)

	{
		logFormat := cfg.NotZeroStr(
			config.LogFormat,
			g.VHostLogFormat,
		)

		logf, err := alog.NewSessionLogFormat(logFormat)
		if err != nil {
			return nil, err
		}
		vhost.LogFormat = logf
	}

	// ServiceList handling
	var serviceList []*vhostService

	for _, svc := range config.ServiceList {

		factory := service.GetServiceFactory(svc.Name)
		if factory == nil {
			return nil, fmt.Errorf("service %s is unknown", svc.Name)
		}
		service, err := factory.Create(svc)
		if err != nil {
			return nil, err
		}
		asvc, err := newvhostService(
			vhost,
			service,
			svc,
		)
		if err != nil {
			return nil, err
		}

		serviceList = append(serviceList, asvc)

		// router setup
		if err := vhost.newRouter(asvc, svc.Router, router); err != nil {
			return nil, err
		}
	}

	// finish the creation of VHost object
	vhost.Name = config.Name
	vhost.Router = router
	vhost.ActiveService = serviceList
	vhost.HttpServer = &http.Server{
		Addr:           config.Endpoint,
		Handler:        router,
		ReadTimeout:    time.Duration(config.ReadTimeout) * time.Second,
		WriteTimeout:   time.Duration(config.WriteTimeout) * time.Second,
		MaxHeaderBytes: config.MaxHeaderSize,
	}
	vhost.clientPool = hclient.NewHClientPool(
		vhost.Name,
		cfg.NotZeroInt64(config.Resource.HttpClientPoolMaxSize, g.VHostHttpClientPoolMaxSize),
		cfg.NotZeroInt64(config.Resource.HttpClientTimeout, g.VHostHttpClientTimeout),
		cfg.NotZeroInt64(config.Resource.HttpClientMaxDrainSize, g.VHostHttpClientMaxDrainSize),
	)

	vhost.builtinHandler(router)

	return vhost, nil
}
